<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RPG Battle Mockup</title>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #171a21;
      --panel-2: #1e222b;
      --text: #e7ebf3;
      --muted: #a7b0c0;
      --accent: #5aa2ff;
      --hp: #ff5a5a;
      --mp: #5abaff;
      --bar-bg: #2a2f3a;
      --good: #46d369;
      --warn: #f2c94c;
      --bad: #ff6b6b;
      --radius: 14px;
      --max-width: 520px; /* column width on desktop */
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
      background: radial-gradient(1200px 800px at 50% -10%, #1a1f2b 0%, var(--bg) 40%);
    }

    .page {
      min-height: 100dvh;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 16px;
    }

    .column {
      width: 100%;
      max-width: var(--max-width);
      display: grid;
      gap: 12px;
    }

    .card {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid #2a2f3a;
      border-radius: var(--radius);
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
    }

    .monster {
      position: relative;
      overflow: hidden;
      display: grid;
    }

    .monster-img {
      width: 100%;
      display: block;
      aspect-ratio: 16 / 10;
      object-fit: contain;
      background: #111;
    }

    .monster-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      padding: 12px;
      background: linear-gradient( to top, rgba(0,0,0,0.55) 0%, rgba(0,0,0,0.25) 40%, rgba(0,0,0,0) 70% );
      pointer-events: none;
    }

    .monster-meta {
      display: grid;
      gap: 6px;
    }

    .monster-name {
      font-weight: 700;
      font-size: 1.25rem;
      letter-spacing: 0.4px;
      text-shadow: 0 2px 12px rgba(0,0,0,0.6);
    }

    .monster-stats {
      display: grid;
      gap: 6px;
      min-width: 48%;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 0.875rem;
      width: fit-content;
      pointer-events: auto; /* allow selection */
    }

    .row { display: flex; align-items: center; gap: 8px; width: 100%; }

    /* Bars */
    .bar {
      position: relative;
      width: 100%;
      height: 16px;
      background: var(--bar-bg);
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid #3a4152;
    }
    .bar-fill { position: absolute; inset: 0 0 0 0; width: 50%; height: 100%; background: var(--hp); }
    .bar-text {
      position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
      font-size: 0.78rem; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.7);
      mix-blend-mode: normal;
    }

    .story { padding: 12px 14px; line-height: 1.45; color: var(--muted); 
			  max-height: 10em;   /* about 5 lines tall */
			  overflow-y: auto; }

    .actions { padding: 10px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
    .action-btn {
      width: 100%;
      padding: 10px 12px;
      font-size: 1rem;
      border-radius: 10px;
      border: 1px solid #2b3241;
      background: #202532;
      color: var(--text);
      cursor: pointer;
      transition: transform 0.04s ease, background 0.2s ease, border-color 0.2s ease;
      touch-action: manipulation;
    }
    .action-btn:hover { background: #263043; }
    .action-btn:active { transform: translateY(1px) scale(0.995); }

    .party {
      padding: 10px;
      display: flex;            /* horizontal layout */
      gap: 10px;
      flex-wrap: wrap;          /* wrap on small screens */
      justify-content: center;  /* center the row */
    }

    .member {
      display: grid;
      grid-template-columns: 1fr; /* vertical tile */
      gap: 8px;
      align-items: start;
      justify-items: center;
      text-align: center;
      padding: 10px;
      border-radius: 12px;
      background: #202534;
      border: 1px solid #2a3142;
      /* make each card size nicely in the row */
      flex: 1 1 clamp(160px, 45%, 220px);
      max-width: 240px;
    }

    .avatar {
      width: 72px; height: 72px; border-radius: 10px; overflow: hidden; border: 1px solid #3a4152; background: #0b0e13;
    }
    .avatar img { width: 100%; height: 100%; object-fit: cover; display: block; }

    .member-main { display: grid; gap: 6px; }
    .member-top { display: flex; align-items: baseline; gap: 8px; }
    .member-name { font-weight: 700; }
    .member-meta { color: var(--muted); font-size: 0.9rem; }

    .label { font-size: 0.78rem; color: var(--muted); min-width: 34px; }

    .controls-placeholder { padding: 16px; color: var(--muted); text-align: center; border: 1px dashed #3a4152; border-radius: var(--radius); background: #1a1f2b; }

    /* Party row tile refinements */
    .member-main { width: 100%; }
    .member-top { justify-content: center; }
    .member .row { display: grid; grid-template-columns: 1fr; gap: 6px; }
    .member .label { justify-self: center; font-size: 0.75rem; }

    @media (min-width: 900px) {
      .party .member { flex: 1 1 calc(25% - 10px); } /* 4 per row on wider screens */
    }

    /* Desktop spacing */
    @media (min-width: 768px) {
      .actions { grid-template-columns: repeat(6, 1fr); }
    }

    /* Clickable portraits */
.member .avatar img { cursor: pointer; }

/* Character modal overlay */
.char-modal-backdrop {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.7);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.char-modal {
  width: min(720px, 92vw);
  max-height: 90vh;
  overflow: auto;
  background: #121623;
  border: 1px solid #2b3140;
  border-radius: 16px;
  padding: 16px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.6);
}

.char-modal-header {
  display: flex;
  justify-content: space-between;
  align-items: start;
  gap: 12px;
  margin-bottom: 12px;
}

.char-modal-title { font-size: 1.2rem; font-weight: 800; }
.char-modal-sub { color: var(--muted); font-size: 0.95rem; }

.char-modal-grid {
  display: grid;
  grid-template-columns: 220px 1fr;
  gap: 14px;
}

.char-modal-portrait {
  width: 220px; height: 220px;
  object-fit: cover;
  border-radius: 12px;
  border: 1px solid #2b3140;
}

.char-modal-close {
  border: 1px solid #2b3140;
  background: #1a1f2b;
  color: #e9eefc;
  border-radius: 10px;
  padding: 6px 10px;
  cursor: pointer;
}

.char-kv { display: grid; grid-template-columns: 120px 1fr; gap: 6px 10px; }
.char-kv .k { color: var(--muted); }
.attack-list { margin: 10px 0 0; padding-left: 18px; }
.attack-list li { margin: 6px 0; }
.attack-meta { color: var(--muted); font-size: 0.9rem; }

  </style>
</head>
<body>
  <div class="page">
    <main class="column">

      <!-- Monster Panel -->
      <section class="card monster" id="monster-panel">
        <img id="monster-img" class="monster-img" alt="Monster" />
        <div class="monster-overlay">
          <div class="monster-meta">
            <div class="monster-name" id="monster-name">??</div>
          </div>
          <div class="monster-stats" id="monster-stats">
			<div class="badge" id="monster-power">Power: 0</div>
            <div class="row">
              <span class="label">HP</span>
              <div class="bar" aria-label="Monster HP">
                <div class="bar-fill" id="monster-hp-fill" style="background: var(--hp); width: 50%"></div>
                <div class="bar-text" id="monster-hp-fill-text">0 / 0</div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Party Panel -->
      <section class="card party" id="party">
        <!-- Party members injected by JS -->
      </section>

      <!-- Story / Situation Text -->
      <section class="card story" id="story">
        The party stands before the old haunted school house. The air hums with dread...and learning potential!<br>
      </section>

      <!-- Primary Actions -->
      <section class="card actions" id="actions">
        <!-- Buttons injected by JS for easy reconfiguration -->
      </section>

    </main>
  </div>

  <!-- Character modal -->
<div id="char-modal-backdrop" class="char-modal-backdrop" aria-hidden="true">
  <div class="char-modal" role="dialog" aria-modal="true" aria-label="Character details">
    <div class="char-modal-header">
      <div>
        <div class="char-modal-title" id="char-modal-title">Character</div>
        <div class="char-modal-sub" id="char-modal-sub"></div>
      </div>
      <button class="char-modal-close" id="char-modal-close">Close</button>
    </div>

    <div class="char-modal-grid">
      <img id="char-modal-portrait" class="char-modal-portrait" alt="Character portrait" />
      <div>
        <div class="char-kv" id="char-modal-kv"></div>
        <div style="margin-top:12px;">
          <div style="font-weight:700;">Attacks</div>
          <ul class="attack-list" id="char-modal-attacks"></ul>
        </div>
        <div style="margin-top:12px;">
          <div style="font-weight:700;">Combat Bonuses</div>
          <ul class="attack-list" id="char-modal-derived"></ul>
        </div>
      </div>
    </div>
  </div>
</div>

  <script>
// ===== Utility: Inline placeholder image (SVG data URL) =====
function placeholderSVG(label = "Image", w = 800, h = 500) {
  const svg = encodeURIComponent(`<?xml version='1.0'?><svg xmlns='http://www.w3.org/2000/svg' width='${w}' height='${h}'>\n<defs><linearGradient id='g' x1='0' y1='0' x2='1' y2='1'><stop offset='0%' stop-color='#263248'/><stop offset='100%' stop-color='#151a24'/></linearGradient></defs>\n<rect width='100%' height='100%' fill='url(#g)'/>\n<text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-family='system-ui,Segoe UI' font-size='32' fill='white' opacity='0.7'>${label}</text></svg>`);
  return `data:image/svg+xml;charset=utf-8,${svg}`;
}

// ===== DOM helpers =====
function el(tag, attrs = {}, children = []) {
  const e = document.createElement(tag);
  for (const [k, v] of Object.entries(attrs)) {
	if (k === 'class') e.className = v;
	else if (k === 'style' && typeof v === 'object') Object.assign(e.style, v);
	else if (k.startsWith('on') && typeof v === 'function') e.addEventListener(k.slice(2), v);
	else if (k === 'dataset') Object.assign(e.dataset, v);
	else e.setAttribute(k, v);
  }
  for (const c of (Array.isArray(children) ? children : [children])) {
	if (c == null) continue;
	if (typeof c === 'string') e.appendChild(document.createTextNode(c));
	else e.appendChild(c);
  }
  return e;
}

// Hide/show Monster Info
function hideMonsterStats() {
  const el1 = document.getElementById('monster-stats');
  if (el1) {el1.style.display = 'none';} else {console.log("el1 is NULL");}
}
function showMonsterStats() {
  const el = document.getElementById('monster-stats');
  if (el) { el.style.display = 'grid';} else {console.log("el is NULL");}
}

// ===== Bars =====
function makeBar(id, colorCSSVar, current, max, aria) {
  const wrap = el('div', { class: 'bar', role: 'progressbar', 'aria-label': aria, 'aria-valuemin': 0, 'aria-valuemax': max, 'aria-valuenow': current });
  const fill = el('div', { class: 'bar-fill', id, style: { background: `var(${colorCSSVar})`, width: `${percent(current, max)}%` } });
  const text = el('div', { class: 'bar-text', id: id + '-text' }, `${current} / ${max}`);
  wrap.append(fill, text);
  return wrap;
}

function percent(cur, max) { return Math.max(0, Math.min(100, max > 0 ? (cur / max) * 100 : 0)); }

function setBar(idBase, cur, max) {
  console.log(`setBar ${idBase} ${cur} / ${max}`);
  const fill = document.getElementById(idBase);
  const text = document.getElementById(idBase + '-text');
  fill.style.width = `${percent(cur, max)}%`;
  text.textContent = `${cur} / ${max}`;
}


/* =========================
   Game UI Conrols
   ========================= */

// ===== Monster UI =====
function renderMonster(mon) {
  document.getElementById('monster-img').src = mon.image;
  document.getElementById('monster-name').textContent = mon.name;
  if (mon.power > 0)
  {
	document.getElementById('monster-power').textContent = `Power: ${mon.power}`;
	setBar('monster-hp-fill', mon.hp, mon.hpMax);
	showMonsterStats();
  }
  else
  {
	hideMonsterStats();
  }
  console.log('monster-name: ' + mon.name);
  console.log('monster-power: ' + mon.power);
}

function setMonster(next) {
  if (!next) {
    console.warn("setMonster called with:", next, "room_index=", Game?.room_index, "state=", Game?.state);
    // Optional: show something obvious instead of leaving stale UI
    renderMonster({ name: "??", image: placeholderSVG("Missing"), power: -1 });
    return;
  }
  state.monster = { ...state.monster, ...next };
  renderMonster(state.monster);
}

function setMonsterHP(hp, hpMax = state.monster.hpMax) { state.monster.hp = hp; state.monster.hpMax = hpMax; setBar('monster-hp-fill', hp, hpMax); }

// ===== Actions UI =====
function renderActions(list) {
  const root = document.getElementById('actions');
  root.innerHTML = '';
  for (const a of list) {
	const btn = el('button', { class: 'action-btn', id: `action-${a.id}`, onclick: (e) => a.handler?.(e) }, a.label);
	root.appendChild(btn);
  }
}
function setActions(list) { state.actions = list; renderActions(list); }

// ===== Party UI =====
function renderParty(members) {
  const root = document.getElementById('party');
  root.innerHTML = '';
  for (const m of members) root.appendChild(renderMember(m));
}

function renderMember(m) {
  const hpBar = makeBar(`hp-${m.id}`, '--hp', m.hp, m.hpMax, `${m.name} HP`);
  const mpBar = makeBar(`mp-${m.id}`, '--mp', m.mp, m.mpMax, `${m.name} MP`);
  return el('div', { class: 'member', id: `member-${m.id}`, dataset: { id: m.id } }, [
	el('div', { class: 'avatar' }, el('img', { alt: `${m.name} portrait`, src: m.image || placeholderSVG(m.name, 200, 200), onclick: () => openCharacterModal(m.id) })),
	el('div', { class: 'member-main' }, [
	  el('div', { class: 'member-top' }, [
		el('div', { class: 'member-name' }, m.name),
		el('div', { class: 'member-meta' }, m.role || '')
	  ]),
	  el('div', { class: 'row' }, [ el('span', { class: 'label' }, 'HP'), hpBar ]),
	  el('div', { class: 'row' }, [ el('span', { class: 'label' }, 'MP'), mpBar ]),
	])
  ]);
}

function setParty(nextMembers) { state.party = nextMembers.map(m => ({ ...m })); renderParty(state.party); }
function setHP(id, hp, hpMax) {
  const m = state.party.find(p => p.id === id);
  if (!m) return;
  if (typeof hp === 'number') m.hp = hp;
  if (typeof hpMax === 'number') m.hpMax = hpMax;
  setBar(`hp-${id}`, m.hp, m.hpMax);
}
function setMP(id, mp, mpMax) {
  const m = state.party.find(p => p.id === id);
  if (!m) return;
  if (typeof mp === 'number') m.mp = mp;
  if (typeof mpMax === 'number') m.mpMax = mpMax;
  setBar(`mp-${id}`, m.mp, m.mpMax);
}

// ===== Story Text =====
function setStory(text) { 
  storyEl = document.getElementById('story')
  storyEl.innerHTML += text +"<br>";
  // Always scroll to bottom to show the latest lines
  storyEl.scrollTop = storyEl.scrollHeight;
}

// ===== Init =====
function init() {
  Game.room_index = 0;
  Game.clue_count = 0;
  // Character modal wiring (once)
  document.getElementById('char-modal-close').onclick = closeCharacterModal;
  document.getElementById('char-modal-backdrop').onclick = (e) => {
    if (e.target.id === 'char-modal-backdrop') closeCharacterModal(); // click outside panel
  };
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closeCharacterModal();
  });

  renderParty(state.party);
  startGameFlow();
}

// Expose minimal API for rapid tinkering in console
window.GameUI = {
  setMonster, setMonsterHP, setActions, setParty, setHP, setMP, setStory
};
	
function openCharacterModal(id) {
  const ch = state.party?.find(p => p.id === id);
  if (!ch) return;

  const backdrop = document.getElementById('char-modal-backdrop');
  const title = document.getElementById('char-modal-title');
  const sub = document.getElementById('char-modal-sub');
  const portrait = document.getElementById('char-modal-portrait');
  const kv = document.getElementById('char-modal-kv');
  const attacksEl = document.getElementById('char-modal-attacks');

  title.textContent = ch.name;
  sub.textContent = `${ch.role || ''}  •  Level ${ch.lvl ?? 1}`;

  portrait.src = ch.image || placeholderSVG(ch.name, 220, 220);
  portrait.alt = `${ch.name} portrait`;

  const rows = [
    ['HP', `${ch.hp}/${ch.hpMax}`],
    ['MP', `${ch.mp}/${ch.mpMax}`],
    ['Weapon', String(ch.weapon ?? 0)],
    ['Armor', String(ch.armor ?? 0)],
    ['Guarded', ch.guarded ? 'Yes' : 'No'],
    ['Note', ch.note || '']
  ];

  kv.innerHTML = rows.map(([k,v]) =>
    `<div class="k">${escapeHtml(k)}</div><div class="v">${escapeHtml(v)}</div>`
  ).join('');

  const attacks = ch.attacks || [];
  attacksEl.innerHTML = attacks.map(a => {
    const dmg = (a.dmg === "*" ? "special" : a.dmg);
    const anytime = a.anytime ? " • anytime" : "";
    return `
      <li>
        <div><b>${escapeHtml(a.name)}</b></div>
        <div class="attack-meta">mp_cost: ${escapeHtml(String(a.mp_cost ?? 0))} • dmg: ${escapeHtml(String(dmg))}${anytime}</div>
      </li>
    `;
  }).join('');

  const derivedEl = document.getElementById('char-modal-derived');
  const derived = computeDerivedCombatInfo(ch);
    derivedEl.innerHTML = derived.map(d =>
    `<li>
      <div><b>${escapeHtml(d.title)}</b></div>
      <div class="attack-meta">${escapeHtml(d.text)}</div>
    </li>`
  ).join('');

  backdrop.style.display = 'flex';
  backdrop.setAttribute('aria-hidden', 'false');
}

function closeCharacterModal() {
  const backdrop = document.getElementById('char-modal-backdrop');
  backdrop.style.display = 'none';
  backdrop.setAttribute('aria-hidden', 'true');
}

// Tiny HTML escaper so notes/strings can't break your modal markup
function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, c => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  }[c]));
}

function computeDerivedCombatInfo(ch) {
  const lvl = ch.lvl || 0;
  const weapon = ch.weapon || 0;
  const armor = ch.armor || 0;

  const info = [];

  // Defense
  let defenseNotes = [`armor ${armor}`];
  if (ch.role === "Rogue") defenseNotes.push(`rogue lvl (${lvl})`);
  defenseNotes.push(`guarded (1 if active)`);
  info.push({
    title: "Defense Roll",
    text: `d6 + ${defenseNotes.join(" + ")}`
  });

  // Strike
  let strikeNotes = [`weapon ${weapon}`];
  if (ch.role === "Warrior") strikeNotes.push(`warrior lvl (${lvl})`);
  if (ch.role === "Cleric") strikeNotes.push(`cleric half-lvl (${Math.floor(lvl / 2)})`);
  info.push({
    title: "Basic Strike Attack",
    text: `d6 + ${strikeNotes.join(" + ")}`
  });

  // Healing (if applicable)
  if (ch.attacks?.some(a => a.name === "Heal" || a.dmg === "*")) {
    info.push({
      title: "Heal",
      text: `d6 + lvl (${lvl}) HP restored`
    });
  }

  return info;
}

/* =========================
   Game Data
   ========================= */
const state = {
  monster: {}, // Set by the room entrance state.
  party: [
	{ id: "p1", name: "Cyra",  role: "Rogue",   hp: 4, hpMax: 4, mp: 1,  mpMax: 1,  image: "images/Cyra.png",
      lvl: 1, weapon: 0, armor: 0, note: "Adds lvl to defense roles",
      attacks: [{name: "Strike", mp_cost: 0, dmg: 1}, {name: "Back Stab (1mp)", mp_cost: 1, dmg: 2}, ],
     guarded: false },
	{ id: "p2", name: "Brann", role: "Warrior", hp: 7, hpMax: 7, mp: 1,  mpMax: 1,  image: "images/Brann.png",
      lvl: 1, weapon: 1, armor: 1, note: "Adds lvl to attack roles",
      attacks: [{name: "Strike", mp_cost: 0, dmg: 1}, {name: "Power Attack (1mp)", mp_cost: 1, dmg: 2}, ],
     guarded: false },
	{ id: "p3", name: "Aeris", role: "Wizard",  hp: 3, hpMax: 3, mp: 4, mpMax: 4, image: "images/Aeris.png",
      lvl: 1, weapon: 0, armor: 0, note: "Adds lvl to magic rolls",
      attacks: [{name: "Strike", mp_cost: 0, dmg: 1}, {name: "Magic Missile (1mp)", mp_cost: 1, dmg: 1}, {name: "Fireball (2mp)", mp_cost: 2, dmg: 2}, ],
     guarded: false },
	{ id: "p4", name: "Dru",   role: "Cleric",  hp: 5, hpMax: 5, mp: 3,  mpMax: 3,  image: "images/Dru.png",
      lvl: 1, weapon: 0, armor: 1, note: "Adds lvl/2 to attack rolls",
      attacks: [{name: "Strike", mp_cost: 0, dmg: 1}, {name: "Heal (1mp)", mp_cost: 1, dmg: "*", anytime: true} ],
     guarded: false },
  ],
  actions: [], // Set by the current state
};

const Rooms = [ // These are rooms  
  { name: "Haunted School Entrance", // 0
	image: "images/HauntedSchool.png",
    power: -1,
	searched : true,
	monster_present : false,
  },
  { name: "Lockers", // 1
	image: "images/Lockers.png",
    power: -1,
	monster_present :
                  { name: "Locker Ghouls", // 1
                  image: 'images/LockersGhouls.png',
                  power: 3,
                  hp: 2,
                  hpMax: 2,
                  },},
  { name: "Haunted Classroom",
	image: "images/Classroom2.png",
    power: -1,
	monster_present :   { name: "Paper Cut Swarm",
	image: 'images/PaperCutSwarm.png',
	power: 4,
	hp: 3,
	hpMax: 3,
  },
  },
  { name: "Cursed Chalkboard",
	image: "images/Classroom1.png",
    power: -1,
	monster_present :
  { name: "Demon Teacher",
	image: 'images/DemonTeacher.png',
	power: 5,
	hp: 4,
	hpMax: 4,
  },
  },
  { name: "Dean Diablo's Office",
	image: "images/DeansOffice.png",
    power: -1,
	monster_present :   { name: "Dean Diablo",
	image: 'images/DeanDiablo.png',
	power: 6,
	hp: 5,
	hpMax: 5,
  },
  },
]
	
/* =========================
   Finite State Framework
   ========================= */

// 1) Enum-like state bag (elephant case)
const State = Object.freeze({
  ROOM:    "EMPTY_ROOM",
  ROOM_ENTRY:    "ROOM_ENTRY",
  MONSTER_APPEARS:  "MONSTER_APPEARS",
  PLAYER_TURN:   "PLAYER_TURN",
  MONSTER_TURN:  "MONSTER_TURN",
  VICTORY:       "VICTORY",
  DEFEAT:        "DEFEAT",
});

// 2) Minimal game data for this flow
const Game = {
  state: State.ROOM, // starts here
  room_index: 0,
  clue_count: 0,
};

// 3) Small helpers

function applyCounters(delta = {}, setAbs = {}) {
  // delta: { room_index: +1/-1, clue_count: +1/-1 }
  // setAbs: { room_index: 0, clue_count: 0 } (absolute set)
  if ("room_index" in delta) Game.room_index += delta.room_index;
  if ("clue_count" in delta) Game.clue_count += delta.clue_count;
  if ("room_index" in setAbs) Game.room_index = setAbs.room_index;
  if ("clue_count" in setAbs) Game.clue_count = setAbs.clue_count;
  if (Game.room_index < 0) Game.room_index = 0;
  if (Game.room_index >= Rooms.length) {
    setStory("That's the end! That's all the rooms there are so far!");
    Game.room_index = Rooms.length - 1;
  }
  if (Game.clue_count > 3) { alert("Solved a Mystery!"); Game.clue_count = 0; }
}

// ===== Dice helper (easy to tweak globally later) =====
function rollD6() {
  return 1 + Math.floor(Math.random() * 6);
}

// ===== Party helpers =====
function livingPartyMembers() {
  return (state.party || []).filter(p => (p.hp || 0) > 0);
}

function allPartyDead() {
  return livingPartyMembers().length === 0;
}

function nextLivingIndex(startIdx) {
  const n = state.party?.length || 0;
  if (!n) return -1;
  for (let i = 0; i < n; i++) {
    const idx = (startIdx + i) % n;
    if ((state.party[idx].hp || 0) > 0) return idx;
  }
  return -1;
}

// Config: how many living targets the monster will try to hit each turn
const MONSTER_TARGETS = 2;

function getMonster() {
  // Your monster is stored in state.monster and has power/hp/hpMax
  return state.monster;
}

function logLines(lines) {
  // setStory appends, so just emit multiple lines cleanly
  for (const line of lines) setStory(line);
}

function makeAction(label, effect) {
  return {
    id: label.toLowerCase().replace(/[^a-z0-9]+/g, "-"),
    label,
    handler: () => {
      effect();                    // adjust counters / do effects
      // transition happens inside each effect via go(nextState)
    },
  };
}

function refreshMonsterPanelForCurrentState() {
  // States where you want to show an actual monster
  if ([State.MONSTER_APPEARS, State.PLAYER_TURN, State.MONSTER_TURN].includes(Game.state)) {
    if (Game.room_index > 0) GameUI.setMonster(Rooms[Game.room_index].monster_present);
    return;
  }
  // Otherwise show the room
  GameUI.setMonster(Rooms[Game.room_index]);
}

function go(nextState) {
  console.log("State:"+Game.state+" room:"+Game.room_index+" clues:"+Game.clue_count);
  Game.state = nextState;
  const fn = EnterHandlers[nextState];
  if (fn) fn();

  // Force UI sync even if an enter handler forgets to set the monster/room
  refreshMonsterPanelForCurrentState();
}

function choosePartyTarget(promptTitle = "Choose a target") {
  const party = state.party || [];
  if (!party.length) return null;

  const lines = party.map((p, i) =>
    `${i + 1}) ${p.name} (${p.role}) HP:${p.hp}/${p.hpMax}`
  );

  const ans = prompt(
    `${promptTitle}\n\n${lines.join("\n")}\n\nType 1-${party.length}:`,
    "1"
  );

  if (ans === null) return null; // user cancelled

  const n = parseInt(String(ans).trim(), 10);
  if (!Number.isFinite(n) || n < 1 || n > party.length) {
    alert(`Please enter a number from 1 to ${party.length}.`);
    return choosePartyTarget(promptTitle);
  }

  return party[n - 1];
}

function doLoot() {
  const roll = rollD6();

  const hauntedSchoolJokes = [
    "You found some crayons, the warrior eats them.",
    "You found extra homework, but no-one volunteers to do it.",
    "You find a suspiciously warm lunch tray… it screams when you touch it.",
    "You open a locker. A ghostly note says: 'See me after death.'",
    "You pick up a hall pass. It’s stamped: DETENTION: ETERNITY.",
    "You discover a cursed bell schedule. Every period is 'Math'.",
  ];

  // Helper: apply stat changes + refresh UI
  function applyToCharacter(ch, fnApply) {
    fnApply(ch);
    // refresh UI bars/stats (you already have these)
    GameUI.setHP(ch.id, ch.hp, ch.hpMax);
    GameUI.setMP(ch.id, ch.mp, ch.mpMax);
    // Optional: if you display weapon/armor on the party tile, re-render party:
    // renderParty(state.party);
  }

  // Outcomes
  if (roll === 1) {
    setStory("Loot found: **Health Potion** (+1 max HP, +1 current HP).");
    const target = choosePartyTarget("Who drinks the Health Potion?");
    if (!target) { setStory("You leave it behind."); return; }

    const beforeMax = target.hpMax;
    const beforeHP  = target.hp;

    applyToCharacter(target, (ch) => {
      ch.hpMax = (ch.hpMax || 0) + 1;
      ch.hp = Math.min(ch.hpMax, (ch.hp || 0) + 1);
    });

    setStory(`${target.name} drinks it. HP ${beforeHP}/${beforeMax} → ${target.hp}/${target.hpMax}.`);
    return;
  }

  if (roll === 2) {
    setStory("Loot found: **Mana Potion** (+1 max MP, +1 current MP).");
    const target = choosePartyTarget("Who drinks the Mana Potion?");
    if (!target) { setStory("You leave it behind."); return; }

    const beforeMax = target.mpMax;
    const beforeMP  = target.mp;

    applyToCharacter(target, (ch) => {
      ch.mpMax = (ch.mpMax || 0) + 1;
      ch.mp = Math.min(ch.mpMax, (ch.mp || 0) + 1);
    });

    setStory(`${target.name} drinks it. MP ${beforeMP}/${beforeMax} → ${target.mp}/${target.mpMax}.`);
    return;
  }

  if (roll === 3) {
    setStory("Loot found: **Weapon Upgrade** (+1 Weapon).");
    const target = choosePartyTarget("Who gets the Weapon Upgrade?");
    if (!target) { setStory("You leave it behind."); return; }

    const before = target.weapon || 0;

    applyToCharacter(target, (ch) => {
      ch.weapon = (ch.weapon || 0) + 1;
    });

    setStory(`${target.name}'s Weapon ${before} → ${target.weapon}.`);
    return;
  }

  if (roll === 4) {
    setStory("Loot found: **Armor Upgrade** (+1 Armor).");
    const target = choosePartyTarget("Who gets the Armor Upgrade?");
    if (!target) { setStory("You leave it behind."); return; }

    const before = target.armor || 0;

    applyToCharacter(target, (ch) => {
      ch.armor = (ch.armor || 0) + 1;
    });

    setStory(`${target.name}'s Armor ${before} → ${target.armor}.`);
    return;
  }

  if (roll === 5) {
    // Party gold is best stored on `state`, not inside the party array.
    if (typeof state.gold !== "number") state.gold = 0;

    const gain = rollD6();
    state.gold += gain;

    setStory(`You found **gold**! +${gain} gold (party gold: ${state.gold}).`);
    return;
  }

  // roll === 6
  setStory("Nothing of value…");
  setStory(hauntedSchoolJokes[Math.floor(Math.random() * hauntedSchoolJokes.length)]);
}

// 4) Enter-state hooks: add buttons and leave TODO comments for future logic
const EnterHandlers = {
  [State.ROOM]: function enter_ROOM() {
    setStory("Now in " + Rooms[Game.room_index].name + " (room#"+Game.room_index+")");
	
    let actions = []
    
    if (!Rooms[Game.room_index].searched) { actions.push(makeAction("Search", () => { setStory("You search the room finding: "); Rooms[Game.room_index].searched = true; doLoot(); go(State.ROOM); } )); }
    if (Game.room_index + 1 < Rooms.length) { actions.push(makeAction("Next Room", () => { applyCounters({ room_index: +1 }); go(State.ROOM_ENTRY); })); }
    if (Game.room_index > 0) { actions.push(makeAction("Retreat", () => { applyCounters({ room_index: -1 }); go(State.ROOM_ENTRY); })); }
	
    setActions(actions);
  },

  // Room Entry events
  [State.ROOM_ENTRY]: function ROOM_ENTRY() {
  Game.active_character = 0;
	if (Rooms[Game.room_index].monster_present !== false)
	{
		setStory("The party encounters a monster.");
		GameUI.setMonster(Rooms[Game.room_index].monster_present);
		go(State.PLAYER_TURN);
	}
	else
	{
		setStory("The party enters '"+Rooms[Game.room_index].name+"'.");
		GameUI.setMonster(Rooms[Game.room_index]);
		go(State.ROOM);
	}
  },

[State.PLAYER_TURN]: function enter_PLAYER_TURN() {
  if (allPartyDead()) { go(State.DEFEAT); return; }

  const mon = getMonster();
  if (!mon || !mon.power || mon.power <= 0) {
    setStory("No monster is present.");
    go(State.ROOM);
    return;
  }

  // Determine who is acting
  if (typeof Game.active_character !== "number") Game.active_character = 0;
  const idx = nextLivingIndex(Game.active_character);
  if (idx < 0) { go(State.DEFEAT); return; }

  Game.active_character = idx;
  const ch = state.party[idx];

  setStory(`Player turn: ${ch.name} (${ch.role})`);

  function endThisCharacterTurn() {
    // advance to next living member; if none left in this round => monster turn
    const nextIdx = nextLivingIndex(idx + 1);
    if (nextIdx < 0 || nextIdx <= idx) {
      // wrapped around (or none), round is over
      Game.active_character = 0;
      go(State.MONSTER_TURN);
    } else {
      Game.active_character = nextIdx;
      go(State.PLAYER_TURN);
    }
  }

  function spendMP(amount) {
    ch.mp = Math.max(0, (ch.mp || 0) - amount);
    GameUI.setMP(ch.id, ch.mp, ch.mpMax);
  }

  function dealDamageToMonster(dmg) {
    mon.hp = Math.max(0, (mon.hp || 0) - dmg);
    GameUI.setMonsterHP(mon.hp, mon.hpMax);
  }

  function doAttack(atk) {
  // Any non-guard action removes guarded state from that character
  ch.guarded = false;

  // ===== HEAL SPECIAL CASE =====
  if (atk.name === "Heal" || atk.dmg === "*") {
    const target = choosePartyTarget(`${ch.name} casts Heal. Who do you heal?`);
    if (!target) {
      setStory("Heal cancelled.");
      // Important: don't spend MP or advance turn if user cancels
      return;
    }

    const roll = rollD6();
    const bonus = (ch.lvl || 0);
    const amount = roll + bonus;

    // spend MP
    spendMP(atk.mp_cost || 0);

    const before = target.hp || 0;
    target.hp = Math.min(target.hpMax || 0, before + amount);
    GameUI.setHP(target.id, target.hp, target.hpMax);

    logLines([
      `${ch.name} uses Heal on ${target.name}.`,
      `Heal roll: ${roll} + lvl:${bonus} = ${amount}`,
      `${target.name} HP: ${before}/${target.hpMax} → ${target.hp}/${target.hpMax}`
    ]);

    endThisCharacterTurn();
    return;
  }

    const roll = rollD6();
    let total = roll;

    const isStrike = atk.name === "Strike";
    if (isStrike) {
      total += (ch.weapon || 0);
      if (ch.role === "Warrior") total += (ch.lvl || 0);
      if (ch.role === "Cleric") total += Math.floor((ch.lvl || 0) / 2);
    } else {
      total += (ch.lvl || 0);
    }

    spendMP(atk.mp_cost || 0);

    logLines([
      `${ch.name} uses ${atk.name} on ${mon.name}.`,
      `Attack roll: ${roll}` +
        (isStrike ? ` + weapon:${ch.weapon || 0}` : ` + lvl:${ch.lvl || 0}`) +
        (ch.role === "Warrior" && isStrike ? ` + warrior_lvl:${ch.lvl || 0}` : ``) +
        (ch.role === "Cleric" && isStrike ? ` + cleric_half_lvl:${Math.floor((ch.lvl || 0) / 2)}` : ``) +
        ` = ${total} vs monster_power:${mon.power}`
    ]);

    if (total >= mon.power) {
      const dmg = Number(atk.dmg);
      dealDamageToMonster(dmg);
      logLines([`${mon.name} takes ${dmg} damage.`]);
      if (mon.hp <= 0) {
        setStory(`${mon.name} is defeated!`);
        go(State.VICTORY);
        return;
      }
    } else {
      logLines([`Miss! ${mon.name} takes no damage.`]);
    }

    endThisCharacterTurn();
  }

  // Build action buttons for THIS character
  const actions = [];

  // Retreat only for the first character in the list (index 0), TODO: what if rogue dies?
  if (idx === 0) {
    actions.push(makeAction("Retreat", () => {
      setStory("You retreat to the last room.");
      applyCounters({ room_index: -1 });
      // Clear guarding when leaving combat (optional but sane)
      for (const p of state.party) p.guarded = false;
      Game.active_character = 0;
      go(State.ROOM_ENTRY);
    }));
  }

  // Guard action for everyone
  actions.push(makeAction("Guard", () => {
    ch.guarded = true;
    logLines([
      `${ch.name} guards.`,
      `Guard effect: +1 defense until ${ch.name} takes another action.`
    ]);
    endThisCharacterTurn();
  }));

  // Attack actions (only if mp is sufficient)
  for (const atk of (ch.attacks || [])) {
    const cost = atk.mp_cost || 0;
    if ((ch.mp || 0) >= cost) {
      actions.push(makeAction(atk.name, () => doAttack(atk)));
    }
  }

  setActions(actions);
},

[State.MONSTER_TURN]: function enter_MONSTER_TURN() {
  setActions([]); // no buttons during monster resolution

  const mon = getMonster();
  if (!mon || !mon.power || mon.power <= 0) {
    setStory("No monster is present.");
    go(State.ROOM);
    return;
  }

  setStory("--- The Monster Acts ---");

  // Monster attacks first N living party members in party order
  let attacked = 0;

  for (let i = 0; i < state.party.length && attacked < MONSTER_TARGETS; i++) {
    const ch = state.party[i];
    if (!ch || ch.hp <= 0) continue;

    attacked++;

    const roll = rollD6();
    const armor = ch.armor || 0;
    const rogueBonus = (ch.role === "Rogue") ? (ch.lvl || 0) : 0;
    const guardedBonus = ch.guarded ? 1 : 0;
    const total = roll + armor + rogueBonus + guardedBonus;

    logLines([
      `The ${mon.name} attacks ${ch.name}.`,
      `Defense roll: ${roll} + armor:${armor}` +
        (rogueBonus ? ` + rogue_lvl:${rogueBonus}` : ``) +
        (guardedBonus ? ` + guarded:${guardedBonus}` : ``) +
        ` = ${total} vs monster_power:${mon.power}`
    ]);

    if (total <= mon.power) {
      ch.hp -= 1;
      GameUI.setHP(ch.id, ch.hp, ch.hpMax);
      logLines([`${ch.name} loses 1 HP.`]);
    } else {
      logLines([`${ch.name} loses no HP.`]);
    }
  }

  if (allPartyDead()) {
    go(State.DEFEAT);
    return;
  }

  // After monster finishes, player's turn starts at first character again
  setStory("--- The Party Acts ---");
  Game.active_character = 0;
  go(State.PLAYER_TURN);
},


  [State.VICTORY]: function enter_VICTORY() {
    GameUI.setMonster(Rooms[Game.room_index]);
    Rooms[Game.room_index].monster_present = false;
    setStory("There's treasure here.");
    setActions([
      makeAction("Take Loot", () => { doLoot(); go(State.ROOM); }),
    ]);
  },

  [State.DEFEAT]: function enter_DEFEAT() {
    setStory("The party was defeated.");
    setActions([
      makeAction("Start Over", () => { location.reload(); }),
    ]);
  },
};

// 5) Boot the state machine from the requested initial state & counters
function startGameFlow() {
  Game.room_index = 0;
  Game.clue_count = 0;
  Game.state = State.ROOM;
  go(Game.state);
}

document.addEventListener('DOMContentLoaded', init);

  </script>
</body>
</html>
